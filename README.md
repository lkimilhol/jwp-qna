## 1단계 요구사항

* 아래의 DDL에 맞는 엔티티를 설계한다.

```sql
create table answer
(
    id          bigint generated by default as identity,
    contents    clob,
    created_at  timestamp not null,
    deleted     boolean   not null,
    question_id bigint,
    updated_at  timestamp,
    writer_id   bigint,
    primary key (id)
)

create table delete_history
(
    id            bigint generated by default as identity,
    content_id    bigint,
    content_type  varchar(255),
    create_date   timestamp,
    deleted_by_id bigint,
    primary key (id)
)

create table question
(
    id         bigint generated by default as identity,
    contents   clob,
    created_at timestamp    not null,
    deleted    boolean      not null,
    title      varchar(100) not null,
    updated_at timestamp,
    writer_id  bigint,
    primary key (id)
)

create table user
(
    id         bigint generated by default as identity,
    created_at timestamp   not null,
    email      varchar(50),
    name       varchar(20) not null,
    password   varchar(20) not null,
    updated_at timestamp,
    user_id    varchar(20) not null,
    primary key (id)
)

alter table user
add constraint UK_a3imlf41l37utmxiquukk8ajc unique (user_id)

```

* User, Question, Answer 순으로 엔티티를 매핑한다.
* 각각의 엔티티 매핑을 진행하며 테스트케이스를 작성한다.
* 공통으로 사용하는 컬럼을 분리 가능한지 체크
* 코드 정리

###1단계 질문

Q. 유저 삭제 테스트케이스를 userRepository.delete(JAVAJIGI) 를 실행하여 단독 테스트케이스 실행시에 성공을 했었는데요. 전체 테스트케이스 실행에서는 실패가 되었습니다.  
다른 테스트케이스 실행이 영향을 끼칠 수 있을거 같아서 @BeforeEach 애노테이션으로 userRepository.deleteAll()을 실행하게 하였는데 마찬가지로 테스트케이스는 실패하였습니다.  
원인이 무엇일까요?


## 2단계 요구사항

아래의 DDL을 보고 연관관계 매핑을 한다.

```sql
alter table answer
    add constraint fk_answer_to_question
        foreign key (question_id)
            references question

alter table answer
    add constraint fk_answer_writer
        foreign key (writer_id)
            references user

alter table delete_history
    add constraint fk_delete_history_to_user
        foreign key (deleted_by_id)
            references user

alter table question
    add constraint fk_question_writer
        foreign key (writer_id)
            references user
```

* 연관관계 매핑을 하여 외래키가 제대로 걸리는지 테스트한다.
* 테스트 케이스에서 데이터가 의도한 대로 CRUD 되었는지 확인한다.

## 3단계 요구사항

* QnaService의 *deleteQuestion()*  메서드에서 단위 테스트가 쉬운 부분을 찾는다.
* 단위 테스트하기 쉬운 부분에 대해 단위 테스트를 구현한다. (최대한 도메인으로 로직을 이동한다)
* 리팩토링을 통해 도메인으로 로직을 이동시킨다.
* 테스트가 통과되는지 체크한다.
* 필요한 부분을 리팩토링한다.

### 3단계 질문사항.

Q. 이번 미션의 목표는 deleteQuestion 메서드를 리팩토링 하는 부분이었는데요.  처음 구현한 방법은 Question 객체에서 Answers 라는 일급 컬렉션을 가지고 있으니 Answers 일급 컬렉션 안에서 Answer를 순회하며 Answer를 delete 하도록 하였는데요.  구현을 하고 테스트를 해보니 Mock에서 사용하지 않는 stubbing이 있었다는 에러 메시지와 함께 테스트가 실패하였습니다.  확인을 해보니 answerRepository의 findByQuestionIdAndDeletedFalse 메서드가 실행되지 않아 테스트가 실패하였는데요. 차라리 테스트 케이스의 내용을 좀 수정하고 일급 컬렉션 안에서 answer를 순회하며 delete를 하는것이 더 좋은 설계 였을까요?

현재 제출한 미션에서는 QnaService 내의 deleteQuestion 메서드를 deleteQna 메서드로 이름을 수정하고, question과 answer를 delete 해주는 로직을 분류 하였습니다. question과 answer 객체에서 각각 delete를 따로 구현하는 것을 생각하여 구현 하였는데요. 제가 개발한 방식도 괜찮은지 조금 의견을 들어보고 싶습니다! 
